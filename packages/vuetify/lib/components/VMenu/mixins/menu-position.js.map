{"version":3,"sources":["../../../../src/components/VMenu/mixins/menu-position.js"],"names":[],"mappings":";;;;;;;;AAQA;AACA,eAAe;AACb,aAAS;AACP;AACA,uBAFO,6BAEQ;AACb,gBAAI,KAAK,aAAL,KAAuB,IAA3B,EAAiC;AAEjC,gBAAI,YAAY,CAAhB;AAEA,gBAAI,KAAK,aAAL,IAAsB,KAAK,SAA/B,EAA0C;AACxC,4BAAY,KAAK,KAAL,CAAW,OAAX,CAAmB,YAA/B;AACD,aAFD,MAEO,IAAI,KAAK,aAAL,GAAqB,KAAK,UAA9B,EAA0C;AAC/C;AACE;AACC,qBAAK,aAAL,GAAqB,KAAK,UAA3B;AACA;AACC,qBAAK,UAAL,GAAkB,CAFnB;AAGA;AACC,qBAAK,aAAL,GAAqB,CAJtB;AAKA;AACA,mBARF;AAUD;AAED,gBAAI,KAAK,KAAL,CAAW,OAAf,EAAwB;AACtB,qBAAK,KAAL,CAAW,OAAX,CAAmB,SAAnB,GAA+B,SAA/B;AACD;AACF,SAzBM;AA0BP,oBA1BO,0BA0BK;AACV,gBAAI,KAAK,UAAT,EAAqB,OAAO,CAAP;AAErB,mBAAO,SAAS,KAAK,UAAL,CAAgB,SAAhB,CAA0B,IAA1B,GAAiC,KAAK,aAAL,GAAqB,CAA/D,CAAP;AACD,SA9BM;AA+BP,mBA/BO,yBA+BI;AACT,gBAAM,gBAAgB,MAAM,IAAN,CAAW,KAAK,KAAhB,EACnB,SADmB,CACT;AAAA,uBAAK,EAAE,SAAF,CAAY,QAAZ,CAAqB,sBAArB,CAAL;AAAA,aADS,CAAtB;AAGA,gBAAI,kBAAkB,CAAC,CAAvB,EAA0B;AACxB,qBAAK,aAAL,GAAqB,IAArB;AAEA,uBAAO,KAAK,WAAZ;AACD;AAED,iBAAK,aAAL,GAAqB,aAArB;AACA,iBAAK,SAAL,GAAiB,KAAK,KAAL,CAAW,MAAX,GAAoB,CAApB,GACb,KAAK,KAAL,CAAW,MAAX,GAAoB,CADP,GAEb,KAAK,KAAL,CAAW,MAFf;AAGA,gBAAI,mBAAmB,KAAK,aAA5B;AACA,gBAAI,sBAAJ;AAEA;AACA,gBAAI,gBAAgB,KAAK,UAArB,IACF,gBAAgB,KAAK,SADvB,EAEE;AACA,gCAAgB,MAAM,KAAK,UAA3B;AACF;AACC,aALD,MAKO,IAAI,iBAAiB,KAAK,SAA1B,EAAqC;AAC1C;AACA;AACA;AACA,oCAAoB,CAApB;AACA,gCAAgB,CAAC,gBAAgB,KAAK,SAAtB,IAAmC,KAAK,UAAxD;AACF;AACC,aAPM,MAOA;AACL,gCAAgB,gBAAgB,KAAK,UAArC;AACD;AAED,mBACE,KAAK,WAAL,GACA,gBADA,GAEA,aAFA,GAGC,KAAK,UAAL,GAAkB,CAJrB;AAMD;AAvEM;AADI,CAAf","sourcesContent":["/**\n * Menu position\n *\n * @mixin\n *\n * Used for calculating an automatic position (used for VSelect)\n * Will position the VMenu content properly over the VSelect\n */\n/* @vue/component */\nexport default {\n  methods: {\n    // Revisit this\n    calculateScroll () {\n      if (this.selectedIndex === null) return\n\n      let scrollTop = 0\n\n      if (this.selectedIndex >= this.stopIndex) {\n        scrollTop = this.$refs.content.scrollHeight\n      } else if (this.selectedIndex > this.startIndex) {\n        scrollTop = (\n          // Top position of selected item\n          (this.selectedIndex * this.tileHeight) +\n          // Remove half of a tile's height\n          (this.tileHeight / 2) +\n          // Account for padding offset on lists\n          (this.defaultOffset / 2) -\n          // Half of the auto content's height\n          100\n        )\n      }\n\n      if (this.$refs.content) {\n        this.$refs.content.scrollTop = scrollTop\n      }\n    },\n    calcLeftAuto () {\n      if (this.isAttached) return 0\n\n      return parseInt(this.dimensions.activator.left - this.defaultOffset * 2)\n    },\n    calcTopAuto () {\n      const selectedIndex = Array.from(this.tiles)\n        .findIndex(n => n.classList.contains('v-list__tile--active'))\n\n      if (selectedIndex === -1) {\n        this.selectedIndex = null\n\n        return this.computedTop\n      }\n\n      this.selectedIndex = selectedIndex\n      this.stopIndex = this.tiles.length > 4\n        ? this.tiles.length - 4\n        : this.tiles.length\n      let additionalOffset = this.defaultOffset\n      let offsetPadding\n\n      // Menu should be centered\n      if (selectedIndex > this.startIndex &&\n        selectedIndex < this.stopIndex\n      ) {\n        offsetPadding = 1.5 * this.tileHeight\n      // Menu should be offset top\n      } else if (selectedIndex >= this.stopIndex) {\n        // Being offset top means\n        // we have to account for top\n        // and bottom list padding\n        additionalOffset *= 2\n        offsetPadding = (selectedIndex - this.stopIndex) * this.tileHeight\n      // Menu should be offset bottom\n      } else {\n        offsetPadding = selectedIndex * this.tileHeight\n      }\n\n      return (\n        this.computedTop +\n        additionalOffset -\n        offsetPadding -\n        (this.tileHeight / 2)\n      )\n    }\n  }\n}\n"],"sourceRoot":""}